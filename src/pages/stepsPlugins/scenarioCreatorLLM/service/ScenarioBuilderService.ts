/* eslint-disable @typescript-eslint/no-explicit-any */
// src/pages/stepsPlugins/scenarioCreatorLLM/service/ScenarioBuilderService.ts
import { Scenario, Task, Step } from '@/types';
import { useScenarioStore, useTaskStore, useStepStore, useDataStore } from '@/store';

/**
 * Service responsible for creating scenarios, tasks and steps from LLM data
 */
class ScenarioBuilderService {
  /**
   * Create scenarios, tasks, and steps from LLM-generated data
   * 
   * @param llmData The data generated by the LLM
   * @param projectPrefix Prefix for folder names
   * @returns Created scenarios, tasks, and steps
   */
  public static async createFromLLMData(
    llmData: any,
    projectPrefix: string = 'LLM Campaign'
  ): Promise<{
    scenarios: Scenario[];
    tasks: Task[];
    steps: Step[];
  }> {
    // Initialize result
    const result = {
      scenarios: [] as Scenario[],
      tasks: [] as Task[],
      steps: [] as Step[]
    };
    
    // Get stores
    const scenarioStore = useScenarioStore.getState();
    const taskStore = useTaskStore.getState();
    const stepStore = useStepStore.getState();
    
    // Create a mapping from scenario reference to actual ID
    const scenarioMapping: Record<string, string> = {};
    const taskMapping: Record<string, string> = {};
    
    // 1. First create all scenarios
    if (llmData.scenarios && Array.isArray(llmData.scenarios)) {
      for (const scenarioData of llmData.scenarios) {
        try {
          // Create folder for the scenario
          const folder = await this.createFolder(
            `${projectPrefix}: ${scenarioData.title}`,
            'scenarios'
          );
          
          if (!folder) {
            console.error(`Failed to create folder for scenario: ${scenarioData.title}`);
            continue;
          }
          
          // Generate a unique ID for the scenario
          const scenarioId = `scenario-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
          
          // Create the scenario
          const scenario: Scenario = {
            id: scenarioId,
            title: scenarioData.title,
            description: scenarioData.description || '',
            objective: scenarioData.objective || '',
            progress: 0,
            tasks: 0,
            completedTasks: 0,
            connections: [],
            dueDate: this.generateDueDate(30),
            folderId: folder.id
          };
          
          // Store the original ID to actual ID mapping
          scenarioMapping[scenarioData.id] = scenario.id;
          
          // Add to store
          scenarioStore.addScenario(scenario);
          result.scenarios.push(scenario);
          
          // Small delay to prevent race conditions
          await this.delay(50);
        } catch (error) {
          console.error(`Error creating scenario: ${error}`);
        }
      }
      
      // Create connections between scenarios after all are created
      for (const scenarioData of llmData.scenarios) {
        if (scenarioData.connections && Array.isArray(scenarioData.connections)) {
          for (const connectionRef of scenarioData.connections) {
            const sourceId = scenarioMapping[scenarioData.id];
            const targetId = scenarioMapping[connectionRef];
            
            if (sourceId && targetId) {
              scenarioStore.addConnection(sourceId, targetId);
            }
          }
        }
      }
    }
    
    // Small delay to ensure scenarios are fully stored
    await this.delay(200);
    
    // 2. Create tasks for each scenario
    if (llmData.tasks && Array.isArray(llmData.tasks)) {
      for (const taskData of llmData.tasks) {
        try {
          // Get the scenario ID this task belongs to
          const scenarioId = scenarioMapping[taskData.scenarioRef];
          
          if (!scenarioId) {
            console.error(`Could not find scenario for task: ${taskData.title}`);
            continue;
          }
          
          // Generate a unique ID for the task
          const taskId = `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
          
          // Create the task
          const task: Task = {
            id: taskId,
            title: taskData.title,
            description: taskData.description || '',
            status: 'todo',
            priority: taskData.priority || 'medium',
            dueDate: this.generateDueDate(14),
            scenarioId: scenarioId,
            currentStepId: null,
            data: {}
          };
          
          // Add mapping for task title to ID (for steps)
          taskMapping[taskData.title] = task.id;
          
          // Add to store
          const addResult = taskStore.addTask(task);
          
          if (addResult.success) {
            result.tasks.push(task);
          }
          
          // Small delay to prevent race conditions
          await this.delay(50);
        } catch (error) {
          console.error(`Error creating task: ${error}`);
        }
      }
    }
    
    // Small delay to ensure tasks are fully stored
    await this.delay(200);
    
    // 3. Create steps for each task
    if (llmData.steps && Array.isArray(llmData.steps)) {
      for (const stepData of llmData.steps) {
        try {
          // Get the task ID this step belongs to
          const taskId = taskMapping[stepData.taskRef];
          
          if (!taskId) {
            console.error(`Could not find task for step: ${stepData.title}`);
            continue;
          }
          
          // Create step configuration based on step type
          let stepConfig: any = {
            title: stepData.title,
            description: stepData.description || ''
          };
          
          // Add type-specific configuration
          if (stepData.type === 'text-input') {
            stepConfig = {
              ...stepConfig,
              placeholder: "Enter your information here...",
              required: true,
              multiline: true,
              rows: 6
            };
          } else if (stepData.type === 'simple-plugin') {
            // Nothing special needed for simple plugin
          } else if (stepData.type === 'step-reference') {
            // For reference steps, we'll need to set this up in a second pass
            stepConfig.referenceStepId = '';
          }
          
          // Create the step
          const stepId = stepStore.addStep(taskId, {
            title: stepData.title,
            description: stepData.description || '',
            type: stepData.type || 'text-input',
            config: stepConfig,
            options: {},  // Add the required options property
            status: 'pending',
            result: null
          });
          
          // Add to results
          const createdStep = stepStore.getStepById(stepId);
          if (createdStep) {
            result.steps.push(createdStep);
          }
          
          // Small delay to prevent race conditions
          await this.delay(50);
        } catch (error) {
          console.error(`Error creating step: ${error}`);
        }
      }
    }
    
    return result;
  }
  
  /**
   * Create a folder in the system
   * 
   * @param name Folder name
   * @param parentId Parent folder ID
   * @returns Created folder or null if failed
   */
  private static async createFolder(name: string, parentId: string = 'root'): Promise<{ id: string } | null> {
    const dataStore = useDataStore.getState();
    
    const folderId = `folder-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    const result = dataStore.addFolder({
      id: folderId,
      name,
      parentId
    });
    
    if (!result.success) {
      return null;
    }
    
    return { id: folderId };
  }
  
  /**
   * Generate a due date
   * 
   * @param daysFromNow Number of days from now
   * @returns Date string in YYYY-MM-DD format
   */
  private static generateDueDate(daysFromNow: number = 30): string {
    const date = new Date();
    date.setDate(date.getDate() + daysFromNow);
    return date.toISOString().split('T')[0];
  }
  
  /**
   * Utility function for creating delays
   * 
   * @param ms Milliseconds to delay
   * @returns Promise that resolves after the delay
   */
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default ScenarioBuilderService;